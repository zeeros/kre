#+TITLE: Object-Oriented Representation

* Frame model (Minsky)

A *frame* is a knowledge structure used to represent objects and object types. Frames can be
- Individual (or instance) frames :: Represent single objects
- Generic (or class) frames :: Represent categories of objects

Frame properties are *slots* that can be valued with *fillers*. A slot can express
- Generalization :: Can be of two types
  - ~:INSTANCE-OF~ sets the class of an individual frame (e.g. $Tarragona \in City$, ~Tarragona :INSTANCE-OF City~)
  - ~:IS-A~ sets the super-class of a generic frame (e.g. $City \subseteq SocialOrganization$, ~City :IS-A SocialOrganization~), the generic frame is a *specialization*
- Aggregation :: ~:PART-OF~ sets the parts of a frame (e.g. ~Building :PART-OF City~)
- Association :: Defines relations with meaning in both directions
<
Multiple values can be stored with
- Multivalued slot :: e.g. ~Train <:wagons [MIN-CARDINALITY m][MAX-CARDINALITY m'] Wagon>~
- Inverse slot :: e.g. ~Wagon <:PART-OF Train>~, with each wagon pointing to one train
- Chaining values :: e.g. ~Train <:wagons Wagon>~, ~Wagon <:next-wagon Wagon>~

A slot may contain properties, known as *facets*, with information about the slot. For example we can set a facet that attaches procedure to be run
- ~IF-ADDED~ :: When the value of the slot is set
- ~IF-NEEDED~ :: When the value of the slot is asked or used
Other facets may be ~DEFAULT~, ~DOMAIN~, ~MAX/MIN-CARDINALITY~, etc.

* Reasoning frames

Reasoning with frame involves the following stages

** Inheritance

Slots are *inherited* when information is passed from generic frames to their specializations, and finally to their instances. Inherited slots can have different fillers. Frames systems use
- Defeasible inheritance :: Inherit only when no filler can be found
- Multiple inheritance (in some systems) :: Inherit from multiple generics

** Assignment loop

When a value is assigned to an instance, the value is set as a filler of the slot and either
- There is an ~IF-ADDED~ facet, and its procedure is triggered
- Or the first ~IF-ADDED~ procedure in the hierarchy of frames is triggered, otherwise do nothing
When a ~IF-ADDED~ procedure is triggered, the loop is repeated if other slots are filled or new frames instantiated.

** Requiring loop

When a value is required from an instance, if the slot has a filler its value is returned. Otherwise, either
- There is a ~IF-NEEDED~ procedure
- Or the first ~IF-NEEDED~ procedure in the hierarchy of frames is triggered
When a ~IF-NEEDED~ procedure is found its value is returned, otherwise ~unknown~ is returned.
When a ~IF-NEEDED~ procedure is triggered, the loop is repeated if other slots are filled or new frames instantiated.

** Reasoning loop

When an instance is created
- Some slots may be explicitly provided my the user, the others are inherited
- For slot with a filler and a ~IF-PROCEDURE~ procedure, the procedure is run. The loop is repeated if other slots are filled or new frames instantiated.

* Lisp lambda-expressions

In LISP, the generic syntax for lambda-expressions is ~(lambda (v) body)~, with
- lambda ::  Symbol used to define lambda-expressions
- v :: A lambda-list specifying names for the parameters of the function. When the function denoted by the lambda-expression is applied to arguments, the arguments are matched with the parameters specified by the lambda-list.
- body :: Can refer to the arguments by using the parameter names. The body consists of any number of forms (possibly zero). These forms are evaluated in sequence, and the results of the last form only are returned as the results of the application (the value nil is returned if there are zero forms in the body).

The complete syntax of a lambda-expression is
#+BEGIN_SRC
(lambda ({var}*
         [&optional {var | (var [initform [svar]])}*]
         [&rest var]
         [&key {var | ({var | (keyword var)} [initform [svar]])}*
                [&allow-other-keys]]
         [&aux {var | (var [initform])}*)]
   [[{declaration}* | documentation-string]]
   {form}*)
#+END_SRC

Some examples
- ~(lambda (arg) (/ arg 50))~ is a function that returns the value resulting from dividing whatever is passed to it as ~arg~ by ~50~
- ~(multiply-by-seven 3)~ is a function that returns 21, where
  - ~multiply-by-seven~ is a function
  - ~3~ is the argument
- ~((lambda (number) (* 7 number)) 3)~ is a function that returns 21, where
  - ~(lambda (number) (* 7 number))~ is an anonymous function
  - ~3~ is the argument

* Lisp-like notation for daemons

We can define facets such as
- IF-ADDED :: Set ~v~ in the slot and run ~lambda~
- IF-NEEDED :: Run ~lambda~ and return ~v~
These facets can also be used to create or remove frames.

In ~body~ we may find
- Preorder notation :: ~(+ 5 4)~, ~(< 10 15)~
- Assignment :: ~(set slot value)~
- Conditional statement :: ~(if cond then [else])~
- Loops :: ~(while cond body)~
- Environment definition :: ~(let ((var value)(var value)...) body-accessing-vars)~
- Grouping sentences :: ~(sent1 ... sentN)~

We can access values such as
- SELF:slot-name :: The value of ~slot-name~ in the current frame (referred as ~SELF~)
- frame-name:slot-name :: The value of ~slot-name~  in ~frame-name~

* Scripts (Schank & Abelson)

The idea of the *script* model (Schank & Abelson, 1977) is to represent procedural (know-how) knowledge with a frame system: a script is a structure describing a sequence of events (over time) in a context, extending the concept of frame with complex temporal/sequencial events. The following slots are used
- Props :: Properties (frames or labels) being part of the script
- Roles :: Agents (frames or labels) involved in the script definition
- OpeningConditions :: Pre-conditions that make the script valid
- Scene :: Actions in the script
- Results :: Post-conditions that are valid after the script runs
