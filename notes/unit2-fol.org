#+TITLE: First Order Logic

* Syntax
** Symbols

*Logical symbol* have a fixed meaning or use in the language
- Punctuation symbols :: $($,$)$ and  $\cdot$
- Logical connectives :: $\wedge$ for conjunction, $\vee$ for disjunction, $\neg$ for negation, $=$ for equality
- Quantifier symbols :: $\forall$ for universal quantification, $\exists$ for existential quantification
- Variables :: $x,y,z,\dots$, an infinite set of symbols

*Non-logical symbols* have a application-dependent meaning or use
- Predicate symbols :: Used to express relations and denoted by uppercase letters $P, Q, R, \cdots$
- Function symbols :: Used to express functions and denoted by lowercase letters $f$, $g$, $h$, $\cdots$
Also, non-logical symbols have an *arity* (a number of arguments).

** Syntactic expressions

The set of *terms* is inductively defined by
- Variables :: Any variable is a term
- Functions :: Any expression $f(t_1,\cdots ,t_n)$ with arity $n$ and terms $t_1,\cdots ,t_n$ is a term

The set of *formulas* is inductively defined by
- Predicate symbols :: If $t_1,\cdots ,t_n$ are terms and $P$ is a predicate symbol then $P(t_1,\cdots,t_n)$ is a formula
- Equality :: If $t_1, t_2$ are terms then $t_1=t_2$ is a formula
- Negation :: If $\varphi$ is a formula then $\neg \varphi$ is a formula
- Binary connectives :: If $\varphi, \psi$ are formulas then any logical connective between the two forms a formula
- Quantifiers :: If $\varphi$ is a formula and $x$ is a variable then following are formulas
  - $\forall x \varphi$, that is "for all $x$ holds $\varphi$"
  - $\exists x \varphi$, that is "there exists $x$ such that $\varphi$"

** Abbreviations

The *implication* operation can be abbreviated with $\varphi \supset \psi$ (or also $\varphi \rightarrow \psi$, $\varphi \Rightarrow \psi$) instead of the extended form $\neg \varphi \vee \psi$.

The *equivalence* operation can be abbreviated with $\varphi \equiv \psi$ instead of the extended form $(\varphi \supset \psi) \wedge (\psi \supset \varphi)$.

Some equivalences between formulas are listed below
- $x \equiv x$, $x$ is equal to itself
- $x \equiv \neg (( \neg x ))$, $x$ is equal to its double negation
- $(x \wedge y) \equiv \neg ((\neg x) \vee (\neg y))$, the conjunction of $x,y$ is equal to the negation of the disjunction of negated $x,y$
- $(x \vee y) \equiv \neg ((\neg x) \wedge (\neg y))$, the disjunction of $x,y$ is equal to the negation of the conjunction of negated $x,y$
- $(x \supset y) \equiv (\neg x) \vee y$, $x$ implies $y$ is equal to disjunction of the negated $x$ and $y$
- $\forall x.P(x) \equiv \neg (\exists x.\neg P(x))$, "for all $x$ holds $P(x)$" is equal to the negation of "there exists $x$ such that $\neg P(x)$"
- $\exists x.P(x) \equiv \neg (\forall x.\neg P(x))$, "there exists $x$ such that $P(x)$" is equal to the negation of "for all $x$ holds $\neg P(x)$"

** Quantifiers scope

A variable occurence is *bound* in a formula if it lies within the scope of a quantifier, otherwise it's *free*. Consider the formula $\forall y.P(x) \wedge \exists x [P(y) \vee Q(x)]$, the occurences
- $\forall y, \exists y$ are bound, or can also be ignored (so neither bound or free)
- $P(x)$ is a free occurence
- $P(y), Q(x)$ are bound occurences
A formula with no free variable is considered a *sentence*.

* Knowledge Representation
** Know-what knowledge

- Properties :: $object=sun \xrightarrow{property=color} value=yellow$
  - Values as predicates :: $Yellow(sun)$
  - Properties as predicates :: $Color(sun,yellow)$
  - Complex predicates :: $Is(sun, color, yellow)$
- Relationships ::  $object=joseph \xrightarrow{relationship=married} object=mary$
  - Relationship as predicates :: $married(joseph,mary)$
  - Complex predicates :: $relation(joseph,mary,marriage)$
- n-ary relationships :: $(object_1, \cdots, \textbf{object}_i, \cdots, object_n)$
  - $Object_i(object_1, \cdots, object_n)$
  - $Property(object_1, object_2, \cdots, object_n)$
  - $Has/Are(object_1, object_2, \cdots, object_n, property)$
** Know-how knowledge

- Procedural control models :: Sequence, parallel fork, synchronization, alternatives, etc
- Non-monotonic logic :: Rules may reduce the Knowledge Base
* Knowledge Base Cookbook
Given a domain, we can construct a FOL knowledge base following these steps
1. Set the *named individuals*
2. Set the *no-named individuals*
3. For each individual, set the basic *type* as a unary predicate
4. For each individual, set the relevant *attributes* or *properties*
5. For each individual, set its *relationships* with others
6. Set the (total) *functions*
7. Set the (specific or generic) *constraints*
* Examples
** Block-world

Suppose we have 3 blocks stacked on a table, $a,b,c$. The color of $a$ is green, the color of $b$ is unknown and the color of $c$ is not green. We want to know if there is a green block on top of a nongreen one.

We can formalize this problem as follows
- $a,b,c$ are the names of the blocks
- $G$ and $O$ are the predicate symbols for "green" and "on"

So the configuration below can be described with a collection of facts in the KB: $\{O(a,b),O(b,c),G(a),\neg G(c)\}$.

| a | is green      |
| b | unknown color |
| c | is not green  |

Are original question is expressed as: $\exists x \exists y \ G(x) \wedge \neg G(y) \wedge O(x,y)$?
To answer it, we consider the two possible cases for $b$
- If $G(b)$, we know from the KB that $\neg G(c)$ and $O(b,c)$, so $G(b) \wedge \neg G(c) \wedge O(b,c)$ and the answer is yes
- If $\neg G(b)$, we know from the KB that $G(a)$ and $O(a,b)$, so $G(a) \wedge \neg G(b) \wedge O(a,b)$ and the answer is yes
