#+TITLE: [[file:exercises/unit2-rules-ps.org][Rules and Production Systems]]
* Rules

In rule-based knowledge bases we have a database of facts and a collection of rules
- Fact :: Unit of information covering the basic truths of the domain (e.g. ~Parent(john,peter)~)
- Rule $Q \Leftarrow P$ :: Universally qualified ($\forall$) conditional expressing new relations in terms of basic facts. (e.g. $Mother(y,x) \Leftarrow ChildOf(x,y) \wedge Woman(y), \forall x,y \in Domain$)
  - Antecedent $Q$ :: Condition for the rule to be applied (e.g. $ChildOf(x,y) \wedge Woman(y)$)
  - Consequent $P$ :: Single fact satisfied if the rule is applied (e.g. $Mother(y,x)$)

Depending on the antecedent $Q$, the rule may be
- Conjunctive rule :: $Q$ is a conjunction of facts, so all the facts must be satisifed to apply the rule (e.g. $Can\_vote(x) \Leftarrow Person(x) \wedge Adult(x)$
- Disjunctive form :: $Q$ contains at least a disjunction
  - Disjunctive :: $b \Leftarrow a_1 \vee, a_2 \vee \cdots a_k$
  - k-term DNF :: $b \Leftarrow (a_{11} \wedge \cdots \wedge a_{1k_1}) \vee \cdots \vee (a_{i1} \wedge \cdots \wedge a_{ik_i}), j \leq k$ (with $j$ terms in disjunction)
  - k-DNF :: $b \Leftarrow (a_{11} \wedge \cdots \wedge a_{1k_1}) \vee \cdots \vee (a_{i1} \wedge \cdots \wedge a_{ik_i}), k_j \leq k$ (with $k_j$ terms in disjunction term $j$)
  - k-CNF :: $b \Leftarrow (a_{11} \vee \cdots \vee a_{1k_1}) \wedge \cdots \wedge (a_{i1} \vee \cdots \vee a_{ik_i}), k_j \leq k$ (with $k_j$ terms in disjunction term $j$)

The reasoning process with rule-based representation may be affected by several problems, below some possible scenarios.
- Alternative ways of representing the same knowledge :: Consider a set of rules made by the rule $Ancestor(x,y) \Leftarrow Parent(x,y)$ and either rule $1,2,3$. While the knowledge represented is the same, implementing it with different set of rules changes the reasoning time for the same query.
   1. $Ancestor(x,y) \Leftarrow Parent(x,z) \wedge Ancestor (z,y)$
   2. $Ancestor(x,y) \Leftarrow Parent(z,y) \wedge Ancestor (x,z)$
   3. $Ancestor(x,y) \Leftarrow Ancestor(x,z) \wedge Ancestor (z,y)$
- Repeated searches :: The result of a reasoning can be either explicit, implicit or ~NO~ (with a closed-world assumption), but in any case we must avoid repeated searches.
- Order of goals :: e.g. Consider $AmericanCousin(x,Sally)$. Evaluate the restrictive clauses first
  - $AmericanCousin(x,y) \Leftarrow American(x) \vee Cousin(x,y)$ requires a loop for each american (order of millions)
  - $AmericanCousin(x,y) \Leftarrow Cousin(y) \vee American(x)$ requires a loop for each cousin (order of tens)
- Order of rules :: e.g. Consider the following rules and the question $UnivStudent(Sally)$. In the order $1,2,3$ the search will be slow in any case, but in order $3,2,1$ it will be fast in some cases. So most restrcitive rules should be evaluated first.
  1. $UnivStudent(x) \Leftarrow BScStudent(x)$
  2. $UnivStudent(x) \Leftarrow MScStudent(x)$
  3. $UnivStudent(x) \Leftarrow PhDStudent(x)$

Consider the generic rule ~IF P THEN Q~, we can apply different forms of rule-based reasoning
- Forward chaining :: From known facts $P$ to conclusions $Q$ (e.g. John is an adult $\rightarrow$ John can vote)
  - Data-directed reasoning :: Given a set of facts, we apply rules $P \rightarrow Q$ to augment the set of facts until we find the one we are looking for
- Backward chaining :: From known facts $Q$ to conclusions $P$ (e.g. John can vote $\rightarrow$ John is an adult)
  - Goal-directed reasoning :: Given a goal $Q$, we decompose $Q$ into pending subgoals by using the rule $P \rightarrow Q$ until there are no more pending goals

* Production Systems

- Production system (PS) :: Forward chaining system that uses PRs and a WM
- Production rule (PR) :: Two-part structure for antecedent $Q$ (that is a conjunctive rule) and consequent $P$. Conditions in $Q$ are evaluated with the current WM in a three-step cycle
  - Recognize active rules :: Populate the set of rules that can be applied
  - Resolve conflicts :: Select one rule from the previous set
  - Trigger rule :: Change the WM according to the actions of the selected rule
- Working memory (WM) :: Set of working memory elements (order is irrelevant)
- Working memory element (WME) :: An n-tuple of the form $(type\quad att_1:val_1 \cdots att_n:val_n)$ with $type,att_i,val_i$ as atoms
- Production rule antecedent :: A set of either positive or negative conditions of the form  $(type\quad att_1:spec_1 \cdots att_n:spec_n)$ with $type, att_i$ atoms and $spec_i$ as
  - An atom
  - A variable
  - An evaluable expression in square brackets, $[]$
  - A test in curly brackets, $\{\}$
  - A conjunction/disjunction/negation of a $spec$
- Production rule consequents :: An ordered sequence of actions affecting the WM, where actions can be
  - ADD $pattern$ :: Add a new WME $pattern$
  - REMOVE $i$ :: Remove the WME matching the i-th condition in the antecedent of the rule
  - MODIFY $i$ ($att\ spec$) :: Replace the current value of $att$ with $spec$ in the WME matching the i-th condition in the antecedent of the rule
