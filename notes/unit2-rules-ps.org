#+TITLE: [[file:exercises/unit2-rules-ps.org][Rules and Production Systems]]
* Rules

In rule-based knowledge bases we have a database of facts and a collection of rules
- Fact :: Unit of information covering the basic truths of the domain (e.g. ~Parent(john,peter)~)
- Rule $Q \Leftarrow P$ :: Universally qualified ($\forall$) conditional expressing new relations in terms of basic facts. (e.g. $Mother(y,x) \Leftarrow ChildOf(x,y) \wedge Woman(y), \forall x,y \in Domain$)
  - Antecedent $P$ :: Condition for the rule to be applied (e.g. $ChildOf(x,y) \wedge Woman(y)$)
  - Consequent $Q$ :: Single fact satisfied if the rule is applied (e.g. $Mother(y,x)$)

Depending on the antecedent $P$, the rule may be
- Conjunctive rule :: $P$ is a conjunction of facts, so all the facts must be satisifed to apply the rule (e.g. $Can\_vote(x) \Leftarrow Person(x) \wedge Adult(x)$)
- Disjunctive form :: $P$ contains at least a disjunction
  - Disjunctive :: $b \Leftarrow a_1 \vee, a_2 \vee \cdots a_k$
  - k-term DNF :: $b \Leftarrow (a_{11} \wedge \cdots \wedge a_{1k_1}) \vee \cdots \vee (a_{i1} \wedge \cdots \wedge a_{ik_i}), j \leq k$ (with $j$ terms in disjunction)
  - k-DNF :: $b \Leftarrow (a_{11} \wedge \cdots \wedge a_{1k_1}) \vee \cdots \vee (a_{i1} \wedge \cdots \wedge a_{ik_i}), k_j \leq k$ (with $k_j$ terms in disjunction term $j$)
  - k-CNF :: $b \Leftarrow (a_{11} \vee \cdots \vee a_{1k_1}) \wedge \cdots \wedge (a_{i1} \vee \cdots \vee a_{ik_i}), k_j \leq k$ (with $k_j$ terms in disjunction term $j$)

The reasoning process with rule-based representation may be affected by several problems, below some possible scenarios.
- Alternative ways of representing the same knowledge :: Consider a set of rules made by the rule $Ancestor(x,y) \Leftarrow Parent(x,y)$ and either rule $1,2,3$. While the knowledge represented is the same, implementing it with different set of rules changes the reasoning time for the same query.
   1. $Ancestor(x,y) \Leftarrow Parent(x,z) \wedge Ancestor (z,y)$
   2. $Ancestor(x,y) \Leftarrow Parent(z,y) \wedge Ancestor (x,z)$
   3. $Ancestor(x,y) \Leftarrow Ancestor(x,z) \wedge Ancestor (z,y)$
- Repeated searches :: The result of a reasoning can be either explicit, implicit or ~NO~ (with a closed-world assumption), but in any case we must avoid repeated searches.
- Order of goals :: e.g. Consider $AmericanCousin(x,Sally)$. Evaluate the restrictive clauses first
  - $AmericanCousin(x,y) \Leftarrow American(x) \vee Cousin(x,y)$ requires a loop for each american (order of millions)
  - $AmericanCousin(x,y) \Leftarrow Cousin(y) \vee American(x)$ requires a loop for each cousin (order of tens)
- Order of rules :: e.g. Consider the following rules and the question $UnivStudent(Sally)$. In the order $1,2,3$ the search will be slow in any case, but in order $3,2,1$ it will be fast in some cases. So most restrcitive rules should be evaluated first.
  1. $UnivStudent(x) \Leftarrow BScStudent(x)$
  2. $UnivStudent(x) \Leftarrow MScStudent(x)$
  3. $UnivStudent(x) \Leftarrow PhDStudent(x)$

Consider the generic rule ~IF P THEN Q~, we can apply different forms of rule-based reasoning
- Forward chaining :: From known facts of antecedent $P$ to conclusions of consequent $Q$ (e.g. John is an adult $\rightarrow$ John can vote)
  - Data-directed reasoning :: Given a set of facts, we apply rules $P \rightarrow Q$ to augment the set of facts until we find the one we are looking for
- Backward chaining :: From known facts of consequent $Q$ to conclusions of antecedent $P$ (e.g. John can vote $\rightarrow$ John is an adult)
  - Goal-directed reasoning :: Given a goal $Q$, we decompose $Q$ into pending subgoals by using the rule $P \rightarrow Q$ until there are no more pending goals

* Production Systems

A *production system* (PS) is a forward chaining system that uses *production rules* (PR) to represent general knowledge. A *working memory* (WM) is used to store assertions.

A production rule is a two-part structure comprising
- Antecedent conditions :: Set of conditions to be applied on the current state of the WM
- Consequent actions :: Set of actions that eventually modify the WM
A rule is usually written as ~IF conditions THEN actions~.

Production systems repeats a basic three-step cycle
- Recognition :: Populate the set of applicable rules (the rules whose antecedent conditions are satisfied with current WM)
- Conflict solving :: Choose from the applicable rules the ones that should be executed
- Trigger rule :: Change the WM according to the actions of the selected rules
The production system halts when no more rules can fire with the current WM

** Working memory

A *working memory* (WM) is set of *working memory elements* (WMEs).
A WME is a tuple of the form $(type\quad att_1:val_1 \cdots att_n:val_n)$: $type,att_i,val_i$ are all atoms. Note that
- WMEs don't explicitly identify the subject of assertions, but a unique attribute (e.g. $id$) can be used
- Attributes order is irrelevant

** Antecedent side of production rules

*Conditions* in the antecedent of a PR
- Are understood conjunctively, so they all must be true for the rule to be applied
- Can be positive ($cond$) or negative ($-cond$)
- Have the form $(type\quad att_1:spec_1 \cdots att_n:spec_n)$. Each specification $spec_i$ may be
  - An atom
  - A variable
  - An evaluable expression, within $[\ ]$
  - A test, within $\{\ \}$
  - A conjunction ($\wedge$, disjunction $\vee$ or a negation $\neg$ of a specification

For example
- $(person\ age:[n+4]\ occupation:x)$
  - Is satisfied if there is a WME of type $person$ with attribute $age$ equal to $n+4$ ($n$ is specified elsewhere)
  - If $x$ is not bound, the result binds the $occupation$ value to $x$
  - If $x$ is bound, the $occupation$ value must be the same of $x$ value
- $-(person\ age:\{<23 \wedge >6\})$ is satisfied if there is no WME of type $person$ and attribute $age$ between 6 and 23

*Applicable rules* are rules such that, for all the variables in them, there are values that satisfy all the antecedent conditions in the current WM.
- A positive condition is satisfied if there is a matching WME, a negative condition if there is none.
- A WME matches a condition $(type\quad att_1:spec_1 \cdots att_n:spec_n)$ if
  - They have the same $type$
  - Each $att_i:spec_i$ has a corresponding $att_i:value_i$ and $spec_i=value_i$

** Consequent side of production rules

*Actions* are interpreted in a sequencial way and can be either
- ADD $pattern$ :: Add a new WME $pattern$ to the WM
- REMOVE $i$ :: Remove the WME matching the i-th condition in the antecedent of the rule
- MODIFY $i$ ($att\ spec$) :: Replace the current value of $att$ with $spec$ in the WME matching the i-th condition in the antecedent of the rule

If there is a WME of type $student$ with any name (bind the name to $x$) then add a WME of type $person$ with the same name
#+BEGIN_EXAMPLE
IF (student name:x) THEN ADD (person name:x)
#+END_EXAMPLE

If there is a WME with predicate $student$ then change its predicate value to $person$
#+BEGIN_EXAMPLE
IF (assertion predicate:student) THEN MODIFY 1 (predicate person)
#+END_EXAMPLE

Assuming that some rule has added a WME of type $birthday$ at the right time, update the person's age
#+BEGIN_EXAMPLE
IF (person age:x name:n) (birthday who:n)
THEN MODIFY 1 (age [x+1])
     REMOVE 2
#+END_EXAMPLE

Control information can be dealt with using ~REMOVE~
#+BEGIN_EXAMPLE
IF (starting)
THEN REMOVE 1
     ADD (control phase:1)
...
IF (control phase:x) + other conditions
THEN MODIFY 1 (phase [x+1])
#+END_EXAMPLE

** Example: world of bricks

Consider the following case
- Three bricks of different size sit on a heap
- Three possible positions where bricks can be placed
- There is a robot hand that can be used to move bricks to these positions
The goal is to place the blocks in decreasing order of size in each position

Assume the working memory starts holds the following elements
#+BEGIN_EXAMPLE
(counter value:1)
(brick name:A size:10 position:heap)
(brick name:B size:30 position:heap)
(brick name:C size:20 position:heap)
#+END_EXAMPLE

We have to position block $B$ in position $1$, block $C$ in position $2$ and block $A$ in position $1$. To do so we can define two production rules. Note that the two rules are mutually exclusive, so no conflict resolution mechanism is needed.

1. Place the largest available brick in the hand
    #+BEGIN_EXAMPLE
    # if there is a brick in the heap
    IF (brick position:heap name:n size:s)
     # if there is no bigger brick in the heap
     -(brick position:heap size: {>s})
     # if the robot hand is free
     -(brick position:robot-hand)
    # put the brick in the hand
    THEN MODIFY 1 (position:robot-hand)
    #+END_EXAMPLE
2. Place the brick in the hand into the next position (sequentially selecting the positions)
    #+BEGIN_EXAMPLE
    # if there is a block in the hand
    IF (brick position:robot-hand)
    # bind i to the counter value
    (counter value:i)
    # set the current position to i and increase the counter
    THEN MODIFY 1 (position i) MODIFY 2 (value[i+1])
    #+END_EXAMPLE

The rules are fired as follows
1. Rule 1, $B$ satisfies the antecedent conditions and the relative WME is modified as
    #+BEGIN_EXAMPLE
    (brick name:B size:30 position:hand)
    #+END_EXAMPLE
2. Rule 2, $B$ satisfies the antecedent conditions: modify both WME of $B$ and the counter
    #+BEGIN_EXAMPLE
    (brick name:B size:30 position:1)
    (counter value:2)
    #+END_EXAMPLE
3. Rule 1, $C$ satisfies the antecedent conditions and the relative WME is modified as
    #+BEGIN_EXAMPLE
    (brick name:C size:20 position:hand)
    #+END_EXAMPLE
4. Rule 2, $C$ satisfies the antecedent conditions: modify both WME of $C$ and the counter
    #+BEGIN_EXAMPLE
    (brick name:C size:20 position:2)
    (counter value:3)
    #+END_EXAMPLE
5. Rule 1, $A$ satisfies the antecedent conditions and the relative WME is modified as
    #+BEGIN_EXAMPLE
    (brick name:A size:10 position:hand)
    #+END_EXAMPLE
6. Rule 2, $A$ satisfies the antecedent conditions: modify both WME of $A$ and the counter
    #+BEGIN_EXAMPLE
    (brick name:A size:10 position:3)
    (counter value:4)
    #+END_EXAMPLE
7. System halts, no bricks in the heap. The final WM configuration
    #+BEGIN_EXAMPLE
    (counter value:4)
    (brick name:A size:10 position:3)
    (brick name:B size:30 position:1)
    (brick name:C size:20 position:2)
    #+END_EXAMPLE
** Conflict resolution

When several rules may be triggered at the same time a strategy is needed. The system may choose
- Random :: Randomly a rule
- Order :: The first rule in order of presentation
- Specifity :: The most selective rule
- Recency :: The most recent rule, meaning either the last fired rule or the rule matching the last WME edited
- Refractoriness :: To avoid the rule just applied with the same values
